[0m[01;34mTails[0m/  Tails.pm
diff --git a/usr/share/perl5/Tails.pm b/usr/share/perl5/Tails.pm
index 6e5f2a5..b9bcf56 100644
--- a/usr/share/perl5/Tails.pm
+++ b/usr/share/perl5/Tails.pm
@@ -11,11 +11,12 @@ Version
 package Tails;
 
 use 5.10.1;
-use namespace::autoclean;
 use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
+use namespace::clean;
+
 our $VERSION = '1.3';
 
 1;
diff --git a/usr/share/perl5/Tails/Constants.pm b/usr/share/perl5/Tails/Constants.pm
index 915601d..f2a326f 100644
--- a/usr/share/perl5/Tails/Constants.pm
+++ b/usr/share/perl5/Tails/Constants.pm
@@ -1,17 +1,23 @@
 package Tails::Constants;
-use Moose;
-use MooseX::Has::Sugar::Saccharin;
-use MooseX::Types::Moose qw{Str};
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-use Method::Signatures::Simple;
+use Function::Parameters;
 
-has 'system_partition_label' => lazy_build ro Str;
-method _build_system_partition_label { 'Tails' }
+use Moo;
+use MooX::late;
+use namespace::clean;
 
-no Moose;
+has 'system_partition_label' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+);
+
+method _build_system_partition_label () { 'Tails' }
+
+no Moo;
 1; # End of Tails::Constants
diff --git a/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm b/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
index dfa6976..fea73c5 100644
--- a/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
+++ b/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
@@ -1,22 +1,22 @@
 package Tails::Role::DisplayError::Gtk3;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
-
 use Carp::Assert::More;
+use Function::Parameters;
+use Types::Standard qw(InstanceOf Str);
 
-sub display_error {
-    my $self        = shift;
-    my $main_window = shift;
-    my $title       = shift;
-    my $mesg        = shift;
-    assert_isa($main_window, 'Gtk3::Window');
-    assert_defined($title);
-    assert_defined($mesg);
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
 
+method display_error (
+    (InstanceOf['Gtk3::Window']) $main_window,
+    Str $title,
+    Str $mesg
+) {
     say STDERR "$title: $mesg";
 
     my $dialog = Gtk3::MessageDialog->new(
@@ -28,5 +28,5 @@ sub display_error {
     $dialog->run;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::DisplayError::Gtk3
diff --git a/usr/share/perl5/Tails/Role/HasCodeset.pm b/usr/share/perl5/Tails/Role/HasCodeset.pm
index 08ed86c..1a05107 100644
--- a/usr/share/perl5/Tails/Role/HasCodeset.pm
+++ b/usr/share/perl5/Tails/Role/HasCodeset.pm
@@ -5,22 +5,27 @@ Tails::Role::HasCodeset - role to get the codeset being used
 =cut
 
 package Tails::Role::HasCodeset;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
+use Function::Parameters;
 use Try::Tiny;
 
+use Moo::Role; # Moo::Role exports all methods declared after it's "use"'d
+use MooX::late;
+
+use namespace::clean;
+
 has 'codeset'  => (
     isa        => 'Str',
     is         => 'ro',
     lazy_build => 1,
 );
 
-sub _build_codeset {
+method _build_codeset () {
     my $codeset;
     try {
         require I18N::Langinfo;
@@ -32,5 +37,5 @@ sub _build_codeset {
     $codeset;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::HasCodeset
diff --git a/usr/share/perl5/Tails/Role/HasDBus/System.pm b/usr/share/perl5/Tails/Role/HasDBus/System.pm
index 34aefce..185c249 100644
--- a/usr/share/perl5/Tails/Role/HasDBus/System.pm
+++ b/usr/share/perl5/Tails/Role/HasDBus/System.pm
@@ -5,18 +5,21 @@ Tails::HasDBus::System - role providing a connection to the system DBus
 =cut
 
 package Tails::Role::HasDBus::System;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-use Carp::Assert;
 use Carp::Assert::More;
+use Function::Parameters;
 use Net::DBus qw(:typing);
 use Net::DBus::GLib;
 
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
+
 has 'dbus'  => (
     isa        => 'Net::DBus',
     is         => 'ro',
@@ -24,11 +27,11 @@ has 'dbus'  => (
     builder    => '_build_dbus',
 );
 
-sub _build_dbus {
+method _build_dbus () {
     my $dbus = Net::DBus::GLib->system;
     assert_defined($dbus);
     return $dbus;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::HasDBus::System
diff --git a/usr/share/perl5/Tails/Role/HasEncoding.pm b/usr/share/perl5/Tails/Role/HasEncoding.pm
index fdc7ba7..25150e1 100644
--- a/usr/share/perl5/Tails/Role/HasEncoding.pm
+++ b/usr/share/perl5/Tails/Role/HasEncoding.pm
@@ -4,40 +4,42 @@ Tails::Role::HasEncoding - role to provide an Encode::Encoding objet for the cod
 
 =head1 SYNOPSIS
 
-    use MooseX::Declare;
-    class Tails::Daemon with Tails::Role::HasEncoding {
-        method foo (Str $bytes) { $self->encoding-> }
+    package Tails::Daemon;
+    use Moo;
+    with 'Tails::Role::HasEncoding';
+    sub foo {
+       my $self = shift;
+       $self->encoding->decode('bla');
     }
 
-    See Tails::Daemon for a real-life usage example.
-
 =cut
 
 package Tails::Role::HasEncoding;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-with 'Tails::Role::HasCodeset';
 use Encode qw{find_encoding};
-use Moose::Util::TypeConstraints;
+use Function::Parameters;
+
+use Moo::Role; # Moo::Role exports all methods declared after it's "use"'d
+use MooX::late;
+
+with 'Tails::Role::HasCodeset';
 
-class_type('Encode::Encoding');
-class_type('Encode::XS');
+use namespace::clean;
 
 has 'encoding' => (
-    isa        => 'Encode::Encoding | Encode::XS',
+    isa        => 'Encode::Encoding|Encode::XS',
     is         => 'ro',
     lazy_build => 1,
 );
 
-sub _build_encoding {
-    my $self = shift;
+method _build_encoding () {
     find_encoding($self->codeset);
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::HasEncoding
diff --git a/usr/share/perl5/Tails/RunningSystem.pm b/usr/share/perl5/Tails/RunningSystem.pm
index 9409ad4..dc52b3a 100644
--- a/usr/share/perl5/Tails/RunningSystem.pm
+++ b/usr/share/perl5/Tails/RunningSystem.pm
@@ -6,123 +6,157 @@ Tails::RunningSystem - class that represents the running Tails system
 
 package Tails::RunningSystem;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-with 'Tails::Role::HasEncoding';
-with 'Tails::Role::DisplayError::Gtk3';
-
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
 use Carp;
 use Carp::Assert::More;
 use Data::Dumper;
-use Path::Class;
+use Function::Parameters;
+use Path::Tiny;
 use Sys::Statistics::Linux::MemStats;
 use Tails::Constants;
 use Tails::UDisks;
 use Try::Tiny;
+use Types::Path::Tiny qw{Dir};
+use Types::Standard qw(Str);
 
 use Locale::gettext;
 use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-perl5lib");
 
+use Moo;
+use MooX::late;
+
+with 'Tails::Role::HasEncoding';
+with 'Tails::Role::DisplayError::Gtk3';
+
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'upgrade_description_url_schema_version' => lazy_build ro Int;
+has 'upgrade_description_url_schema_version' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Int',
+);
 
-has "$_" => lazy_build ro Str
-    for (
+has "$_" => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+) for (
         qw{baseurl product_name product_version build_target channel},
         qw{upgrade_description_file_url upgrade_description_sig_url},
         qw{dev_dir os_release_file proc_dir run_dir},
     );
 
-has 'udisks' =>
-    lazy_build ro 'Tails::UDisks',
-    handles => [ qw{bytes_array_to_string device_installed_with_tails_installer
-                    get_block_device_property get_drive_property
-                    get_partition_property
-                    underlying_block_device underlying_drive} ];
+has 'udisks' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::UDisks',
+    handles    => [ qw{bytes_array_to_string device_installed_with_tails_installer
+                       get_block_device_property get_drive_property
+                       get_partition_property
+                       underlying_block_device underlying_drive} ],
+);
 
 has 'liveos_mountpoint' => (
-    isa        => 'Path::Class::Dir',
+    isa        => Dir,
     is         => 'rw',
     lazy_build => 1,
-    coerce     => 1,
+    coerce     => Dir->coercion,
     documentation => q{Mountpoint of the Tails system image.},
 );
 
-has 'boot_drive' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the physical drive where Tails is installed, e.g. /org/freedesktop/UDisks2/drives/Verbatim_ABC_2786.};
+has 'boot_drive' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the physical drive where Tails is installed, e.g. /org/freedesktop/UDisks2/drives/Verbatim_ABC_2786.},
+);
 
-has 'boot_block_device' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the block device where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb.};
+has 'boot_block_device' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the block device where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb.}
+);
 
-has 'boot_device_file' =>
-    lazy_build rw Str,
-    documentation => q{The path of the physical drive where Tails is installed, e.g. /dev/sdb.};
+has 'boot_device_file' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The path of the physical drive where Tails is installed, e.g. /dev/sdb.},
+);
 
-has 'system_partition' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the partition where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb1.};
+has 'system_partition' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the partition where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb1.},
+);
 
-has 'system_partition_file' =>
-    lazy_build rw Str,
-    documentation => q{The path of the partition where Tails is installed, e.g. /dev/sdb1.};
+has 'system_partition_file' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The path of the partition where Tails is installed, e.g. /dev/sdb1.},
+);
 
-has 'constants' =>
-    lazy_build ro 'Tails::Constants',
-    metaclass => 'NoGetopt',
-    handles   => [ qw{system_partition_label}];
+has 'constants' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::Constants',
+    handles    => [ qw{system_partition_label}],
+);
 
-has 'main_window' => ro 'Gtk3::Window';
+has 'main_window' => (
+    is  => 'ro',
+    isa => 'Gtk3::Window',
+);
 
-foreach (qw{boot_drive_vendor boot_drive_model}) {
-    has $_ => lazy_build ro Str;
+foreach (qw{boot_drive_vendor boot_drive_model
+            override_started_from_device_installed_with_tails_installer}) {
+    has $_ => (
+        lazy_build => 1,
+        is         => 'ro',
+        isa        => 'Str',
+    );
 }
 
-has 'override_started_from_device_installed_with_tails_installer' =>
-    lazy_build ro Str;
-
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_upgrade_description_url_schema_version { 1 }
-method _build_dev_dir         { '/dev' }
-method _build_os_release_file { '/etc/os-release' }
-method _build_proc_dir        { '/proc' }
-method _build_run_dir         { '/var/run' }
-method _build_product_name    { $self->os_release_get('TAILS_PRODUCT_NAME') }
-method _build_product_version { $self->os_release_get('TAILS_VERSION_ID')   }
-method _build_baseurl         { 'https://tails.boum.org' }
-method _build_udisks          { Tails::UDisks->new(); }
-
-method _build_build_target {
+method _build_upgrade_description_url_schema_version () { 1 }
+method _build_dev_dir () { '/dev' }
+method _build_os_release_file () { '/etc/os-release' }
+method _build_proc_dir () { '/proc' }
+method _build_run_dir () { '/var/run' }
+method _build_product_name () { $self->os_release_get('TAILS_PRODUCT_NAME') }
+method _build_product_version () { $self->os_release_get('TAILS_VERSION_ID') }
+method _build_baseurl () { 'https://tails.boum.org' }
+method _build_udisks () { Tails::UDisks->new(); }
+
+method _build_build_target () {
     my $arch = `dpkg --print-architecture`; chomp $arch; return $arch;
 }
 
-method _build_channel {
+method _build_channel () {
     my $channel;
     try { $channel = $self->os_release_get('TAILS_CHANNEL') };
     defined $channel ? $channel : 'stable';
 }
 
-method _build_upgrade_description_file_url {
+method _build_upgrade_description_file_url () {
     sprintf(
         "%s/upgrade/v%d/%s/%s/%s/%s/upgrades.yml",
         $self->baseurl,
@@ -134,22 +168,19 @@ method _build_upgrade_description_file_url {
     );
 }
 
-method _build_upgrade_description_sig_url {
+method _build_upgrade_description_sig_url () {
     $self->upgrade_description_file_url . '.pgp';
 }
 
-method _build_constants {
+method _build_constants () {
     Tails::Constants->new();
 }
 
-sub _build_liveos_mountpoint {
-    my $self = shift;
-    dir('/lib/live/mount/medium');
+method _build_liveos_mountpoint () {
+    path('/lib/live/mount/medium');
 }
 
-sub _build_boot_block_device {
-    my $self = shift;
-
+method _build_boot_block_device () {
     my $device;
     try {
         $device = $self->underlying_block_device($self->liveos_mountpoint);
@@ -160,7 +191,6 @@ sub _build_boot_block_device {
             $self->encoding->decode(gettext(
                 q{The device Tails is running from cannot be found. Maybe you used the 'toram' option?},
             )),
-            '',
         );
     };
 
@@ -179,9 +209,7 @@ sub _build_boot_block_device {
     return $boot_block_device;
 }
 
-sub _build_boot_drive {
-    my $self = shift;
-
+method _build_boot_drive () {
     my $drive;
     try {
         $drive = $self->underlying_drive($self->liveos_mountpoint);
@@ -200,40 +228,30 @@ sub _build_boot_drive {
     return $drive;
 }
 
-sub _build_boot_device_file {
-    my $self = shift;
-
+method _build_boot_device_file () {
     return $self->bytes_array_to_string($self->get_block_device_property(
         $self->boot_block_device, 'PreferredDevice'
     ));
 }
 
-sub _build_system_partition {
-    my $self = shift;
-
+method _build_system_partition () {
     $self->udisks->device_partition_with_label(
         $self->boot_block_device,
         $self->system_partition_label
     );
 }
 
-sub _build_system_partition_file {
-    my $self = shift;
-
+method _build_system_partition_file () {
     return $self->bytes_array_to_string($self->get_block_device_property(
         $self->system_partition, 'PreferredDevice'
     ));
 }
 
-sub _build_boot_drive_vendor {
-    my $self = shift;
-
+method _build_boot_drive_vendor () {
     $self->get_drive_property($self->boot_drive, 'Vendor');
 }
 
-sub _build_boot_drive_model {
-    my $self = shift;
-
+method _build_boot_drive_model () {
     $self->get_drive_property($self->boot_drive, 'Model');
 }
 
@@ -251,11 +269,11 @@ http://www.freedesktop.org/software/systemd/man/os-release.html
 Throws an exception if not found.
 
 =cut
-method os_release_get ($key) {
+method os_release_get (Str $key) {
     assert(-e $self->os_release_file);
     assert_like($key, qr{[_A-Z]+});
 
-    my $fh = file($self->os_release_file)->openr;
+    my $fh = path($self->os_release_file)->openr;
 
     while (<$fh>) {
         chomp;
@@ -279,7 +297,7 @@ method started_from_device_installed_with_tails_installer () {
 method started_from_writable_device () {
     assert(-d $self->dev_dir);
 
-    -e file($self->dev_dir, 'bilibop');
+    -e path($self->dev_dir, 'bilibop');
 }
 
 =head2 free_memory
@@ -289,12 +307,12 @@ Returns MemFree + Buffers + Cached, in bytes.
 =cut
 method free_memory () {
     assert(-d $self->proc_dir);
-    assert(-e file($self->proc_dir, 'meminfo'));
+    assert(-e path($self->proc_dir, 'meminfo'));
 
     Sys::Statistics::Linux::MemStats->new(
         files => { path => $self->proc_dir }
     )->get->{realfree} * 1024;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/UDisks.pm b/usr/share/perl5/Tails/UDisks.pm
index 7216782..5b84650 100644
--- a/usr/share/perl5/Tails/UDisks.pm
+++ b/usr/share/perl5/Tails/UDisks.pm
@@ -5,20 +5,21 @@ Tails::UDisks - role providing a connection to UDisks via DBus
 =cut
 
 package Tails::UDisks;
-use Moose;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
 use Carp::Assert::More;
 use File::stat;
+use Function::Parameters;
 use IPC::System::Simple qw{capturex};
 use Syntax::Keyword::Junction qw{any};
 use List::Util qw{first};
-use Method::Signatures::Simple;
 use Tails::Constants;
+use Types::Standard qw{ArrayRef Defined Str};
+use Types::Path::Tiny qw{Path};
 use Unix::Mknod qw(:all);
 
 use Locale::gettext;
@@ -26,58 +27,58 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-perl-lib");
 
+use Moo;
+use MooX::late;
+use namespace::clean;
+
 with 'Tails::Role::HasDBus::System';
 
-has 'constants' =>
+has 'constants' => (
     is         => 'ro',
     isa        => 'Tails::Constants',
     lazy_build => 1,
-    metaclass  => 'NoGetopt',
-    handles    => [ qw{system_partition_label}];
+    handles    => [ qw{system_partition_label}],
+);
 
-has 'udisks_service' =>
+has 'udisks_service' => (
     is         => 'ro',
     lazy_build => 1, # Let's decide the right initialization order in BUILD
-    isa        => 'Net::DBus::RemoteService';
+    isa        => 'Net::DBus::RemoteService',
+);
 
-has 'udisks_object' =>
+has 'udisks_object' => (
     is         => 'ro',
     lazy_build => 1, # Let's decide the right initialization order in BUILD
-    isa        => 'Net::DBus::RemoteObject';
-
-sub BUILD {
-    my $self = shift;
+    isa        => 'Net::DBus::RemoteObject',
+);
 
+method BUILD (@args) {
     # Force initialization in correct order
     assert_defined($self->dbus);
     assert_defined($self->udisks_service);
     assert_defined($self->udisks_object);
 }
 
-method _build_constants {
+method _build_constants () {
     Tails::Constants->new();
 }
 
-method _build_udisks_service {
+method _build_udisks_service () {
     $self->dbus->get_service("org.freedesktop.UDisks2");
 }
 
-method _build_udisks_object {
+method _build_udisks_object () {
     $self->udisks_service->get_object(
         "/org/freedesktop/UDisks2",
         "org.freedesktop.DBus.ObjectManager"
     );
 }
 
-method debug {
+method debug (@args) {
     say STDERR @_ if $ENV{DEBUG};
 }
 
-method get_udisks_property ($type, $object, $property) {
-    assert_defined($type);
-    assert_defined($object);
-    assert_defined($property);
-
+method get_udisks_property (Str $type, Defined $object, Str $property) {
     $self->debug("Entering get_udisks_property: $type, $object, $property");
     $self->udisks_service
          ->get_object($object)
@@ -85,29 +86,27 @@ method get_udisks_property ($type, $object, $property) {
          ->Get("org.freedesktop.UDisks2.$type", $property);
 }
 
-method get_block_device_property ($device, $property) {
+method get_block_device_property (Defined $device, Str $property) {
     $self->get_udisks_property('Block', $device, $property);
 }
 
-method get_drive_property ($drive, $property) {
+method get_drive_property (Defined $drive, Str $property) {
     $self->get_udisks_property('Drive', $drive, $property);
 }
 
-method get_partition_table_property ($device, $property) {
+method get_partition_table_property (Defined $device, Str $property) {
     $self->get_udisks_property('PartitionTable', $device, $property);
 }
 
-method get_partition_property ($device, $property) {
+method get_partition_property (Defined $device, Str $property) {
     $self->get_udisks_property('Partition', $device, $property);
 }
 
-method get_filesystem_property ($device, $property) {
+method get_filesystem_property (Defined $device, Str $property) {
     $self->get_udisks_property('Filesystem', $device, $property);
 }
 
-method drive_is_connected_via_a_supported_interface ($drive) {
-    assert_defined($drive);
-
+method drive_is_connected_via_a_supported_interface (Defined $drive) {
     $self->debug("Entering drive_is_connected_via_a_supported_interface, $drive");
 
     my $iface = $self->get_drive_property($drive, 'ConnectionBus');
@@ -115,14 +114,11 @@ method drive_is_connected_via_a_supported_interface ($drive) {
     any(qw{sdio usb}) eq $iface;
 }
 
-method drive_is_optical ($drive) {
-    assert_defined($drive);
+method drive_is_optical (Defined $drive) {
     $self->get_drive_property($drive, 'Optical');
 }
 
-method partitions ($device) {
-    assert_defined($device);
-
+method partitions (Defined $device) {
     my $partition_re;
     if ($device =~ m{mmcblk [0-9]+ \z}xms) {
         $partition_re = qr{\A$device[p][0-9]+\z};
@@ -136,9 +132,7 @@ method partitions ($device) {
     } keys %{$self->udisks_object->GetManagedObjects()};
 }
 
-method luks_holder ($device) {
-    assert_defined($device);
-
+method luks_holder (Defined $device) {
     my %objects = %{$self->udisks_object->GetManagedObjects()};
 
     first {
@@ -152,17 +146,13 @@ method luks_holder ($device) {
     } keys %objects;
 }
 
-method bytes_array_to_string ($bytes_array) {
-    assert_listref($bytes_array);
-
+method bytes_array_to_string (ArrayRef $bytes_array) {
     my @bytes_array = @{$bytes_array};
     my $null_terminated_str = pack('(U)*x', @bytes_array);
     return substr($null_terminated_str, 0, length($null_terminated_str) - 2);
 }
 
-method mountpoints ($device) {
-    assert_defined($device);
-
+method mountpoints (Defined $device) {
     my $luks_holder = $self->luks_holder($device);
     my $real_device = $luks_holder ? $luks_holder : $device;
 
@@ -171,26 +161,18 @@ method mountpoints ($device) {
     } @{$self->get_filesystem_property($real_device, 'MountPoints')};
 }
 
-method device_partition_with_label ($device, $label) {
-    assert_defined($device);
-    assert_defined($label);
-
+method device_partition_with_label (Defined $device, Str $label) {
     $self->debug("Entering device_partition_with_label $device, $label");
     first {
         defined && $label eq $self->get_partition_property($_, 'Name')
     } $self->partitions($device)
 }
 
-method device_has_partition_with_label ($device, $label) {
-    assert_defined($device);
-    assert_defined($label);
-
+method device_has_partition_with_label (Defined $device, Str $label) {
     defined $self->device_partition_with_label($device, $label);
 }
 
-method device_installed_with_tails_installer ($device) {
-    assert_defined($device);
-
+method device_installed_with_tails_installer (Defined $device) {
     $self->debug("Entering device_installed_with_tails_installer: $device");
     'gpt' eq $self->get_partition_table_property($device, 'Type')
         or return;
@@ -209,9 +191,7 @@ Returns the physical block device UDI (e.g.
 is stored.
 
 =cut
-method underlying_block_device ($path) {
-    assert_defined($path);
-
+method underlying_block_device (Path $path) {
     $self->debug("Entering underlying_block_device");
     my $st     = stat($path);
 
@@ -234,9 +214,7 @@ Returns the physical drive UDI (e.g.
 is stored.
 
 =cut
-method underlying_drive ($path) {
-    assert_defined($path);
-
+method underlying_drive (Path $path) {
     $self->debug("Entering underlying_drive");
     my $block = $self->underlying_block_device($path);
     $self->debug("block: $block");
@@ -246,5 +224,5 @@ method underlying_drive ($path) {
     return $drive;
 }
 
-no Moose;
+no Moo;
 1; # End of Tails::UDisks
